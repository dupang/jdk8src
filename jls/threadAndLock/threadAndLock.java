package jls.threadAndLock;

/**
 * Created by dupang on 2016/5/22.
 */
public class threadAndLock {
    /**
     * 当一个对象被创建，它的等待集合是空的。增加线程到和删除线程从等待集合中的基本的行为是自动的。
     * 等待集合被操控仅仅通过方法Object.wait,Object.notify,和Object.notifyAll.
     *
     * 等待集合的操控也可以受线程的中断状态的影响，和线程类的处理中断的方法。另外，Thread类的方法
     * sleeping和join()也来自等待和通过的操作。
     *
     * 等待行为发生在调用wait()方法的时候，或者定时的形式的wait(long millisecs)和wait(long millisecs,int nanosecs)
     *    调用wait(long millisecs)传入一个0的参数，或者调用wait(long millsecs,int nanosecs)传入两个0的参数，效果和
     *    调用wait()一样。
     *
     *    一个线程正常地返回从wait方法中，如果它没有抛出异常。
     *
     *    让线程t执行对象m的wait方法，并且n是线程t在对象m上锁操作的数量，并且还没有解锁的操作。
     *    下面的其中一件事发生：
     *    1.如果n是0，(也就是线程t还没有对m执行锁操作)，那么将抛出IllegalMonitorStateExceptio异常。
     *    2.如果这是一个定时的等待并且nanosecs参数范围不在0-999999，或者millisecs参数是负数，那么抛出
     *    IllegalArgumentException异常。
     *    3.如果 线程t被中断，那么抛出InterruptedException异常，并且t的中断状态被设置成false.
     *
     *
     *    否则，下面的顺序发生
     *
     *    1.线程t被加入到对象m的等待集合，并且执行n次解锁操作在m上。
     *    2.线程t不会执行任何更多的指令直到它被从m的等待队列上移除。线程可能从等待集合上移除由于下面的任何一个操作
     *      并且之后的某一时刻恢复。
     *      1》.在对象m上执行notify操作，并且t被选择从m的等待队列中移除。
     *      2》.在对象m上执行notifyAll操作，
     *      3》.在线程t上执行中断操作。
     *      4》.如果这是一个定时的wait,从m的等待中移除t至少经过millsecs毫秒加上nanosecs纳秒。
     *      5》.实现的内部操作，实现被允许，尽管不提倡，执行"虚假唤醒"，也就是说从等待集合中移除线程，并且使它恢复而
     *          没有明确的指令去执行这个。
     *
     *          注意这个规定需要Java编写wait只有在循环中，这个循环只在一些这个线程正在等待的条件满足的时候才终止。
     *
     *      每一个线程必须确定它被从等待集合移除的顺序，这个顺序不必和其它顺序一致，但是这个线程必须表现得像这个顺序
     *      一样。
     *
     *      例如，如果一个线程t正在m的等待集合上，然后线程t的中断和m的唤醒发生。在这些事件上必须有一个顺序。如果线程t
     *      的中断先发生，那么线程t从wait中返回，并抛出一个InterruptedException,并且其它线程在m的等待集合中必须接受到了
     *      唤醒通知。如果通知被认为先发生。那么t最终从wait方法中返回并且中断即将发生。
     *
     *      3.线程t执行n个锁操作在m对象上
     *      4.如果由于中断线程t从m的中断集合中移除。那么t的中断状态被设置成false,并且wait方法抛出InterruptedException.
     *
     *
     *      17.2.2 Notification
     *
     *      通知动作发生在notify和notifyAll方法的时候。
     *
     *      假如线程t是正在对象t上执行这些方法的的线程，并且n是t在m上的锁动作的数量并且没有还没有解锁。下面动作中的其中一个
     *      发生。
     *
     *      1. 如果n是0，那么抛出IllegalMonitorStateException异常。这就是t还没有持有对象m的锁的例子。
     *      2. 如果n是一个大于0的数，并且这是一个notify动作。那么如果m的当前等待集合不会空，线程u是m的等待集合中被选择的
     *         一员，并且从等待集合中移除。
     *
     *         没有保证那一个线程会从等待集合中被选择。从等待集合中移除使u从wait中恢复，然而请注意，在恢复时的u的锁动作不
     *         会成功直到t完全释放了m的监视器。
     *
     *      3. 如果n大于0并且这是一个notifyALl动作，然后所有线程被移除从m的等待集合中。
     *
     *          然而请注意一个时刻只有他们中的其中一个将锁住监视器在从wait中恢复的时候。
     *
     *     17.2.3  中断
     *
     *
     *     中断动作发生在在调用Thread.interrupt的时候，反过来方法被定义的类调用也可以，例如ThreadGroup.interrupt.
     *
     *     假如线程t正在调用u.interrupt,对于一些线程u,t和u可能是一样的。这个动作使u的中断判断被设置成true.
     *
     *     另外，如果存在对象m，它的等待集合中包含u，那么 u被移除从m的等待集合中。这使u从等待动作中恢复过来，
     *     这种情况这个等待将在重新锁m的监视器之后抛出interruption异常。
     *
     *     调用Thread.isInterrupted的方法可以确定一个线程的中断状态。静态方法Thread.interrupted可以被线程调用
     *     来查看它的中断状态并且清除它的中断状态。
     *
     *
     *     这部分提供Java编程语言内存模型的规范，除了处理final字段的问题，这部分将在17.5描述。
     *
     *     这里指出的内存模型不是以Java编程语言的面向对象的特性为基础的。为了我们例子中的简洁和简单，
     *     我们经常展示没有类或方法的代码片断，或显式引用。大部分例子由两个或更多个线程组成 ，这些线程
     *     访问本地变量，共享全局变量，或者对象的实例字段。我们通常使用变量名字r1或r2表示方法或线程的
     *     本地变量。这些变量对其它线程不可访问。
     *
     *     17.4.1 共享变量
     *
     *     可以在线程之间共享的内存被称为共享内存或堆内存。
     *
     *     所有实例字段，static 字段，和数组元素被存储在堆内存。在这章，我们使用术语variable来表示字段和
     *     数组元素。
     *
     *     本地变量，正规的方法参数，和异常处理参数从来不在线程之间共享并且不受线程模型的影响。
     *
     *     相同的变量的两个访问(读或写)操作被认为是冲突的，如果至少其中的一个访问是写操作。
     *
     *     17.4.2 动作
     *
     *     一个inter-thread 动作是一个被一个线程执行的动作，可以被另一个线程检测到或直接影响。有一些
     *     程序可能执行的inter-thread 动作：
     *
     *     1. read(普通，或者not-volatile).读一个变量。
     *     2. write(普通，或者 non-volatile).写一个变量。
     *     3. 同步动作，这些是：
     *       -- Volatile read. 一个volatile变量的读。
     *       -- Volatile write 一个volatile变量的写。
     *       -- 锁 锁一个监视器
     *       -- 解锁 解锁一个监视器
     *       -- 线程的(合成的;  人造的;  摹拟的，虚构的;  [语]综合的)第一个和最后一个动作。
     *       -- 开始一个线程的动作或检测一个线程已经终结的动作。
     *
     *     4. 外部的动作。一个外部的动作是一个可能在一个执行操作外被查看的动作。并且具有一个基于执行
     *     的外部运行环境的结果。
     *
     *     5. Thread divergence actions。 线程分歧动作是只在一个无限循环被线程执行的动作，没有只在，同步，
     *     或者外部动作。如果线程执行一个线程分歧动作，它将被跟着大量的线程分歧动作。
     *
     *
     *     线程分歧动作被引入到模型，一个线程是怎么引起所有其它线程阻塞和失败进展的。
     *
     *     这个规范仅仅关注inter-thread动作。我们不需要关注intra-thread动作(比如，两个本地变量的
     *     相加并且存储结果到第三个本地变量中)。在前面提到的，所有线程需要遵循正确的Java程序intra-thread语义。
     *     我们将经常把inter-thread动作简称为actions.
     *
     *     一个动作a被描述为一个tuple<t,k,v,u>,相应地：
     *      1.t - 执行动作的线程。
     *      2.k - 动作的类型。
     *      3.v - 动作关联的变量或监视器。
     *          对于锁操作，v是被锁住的监视器，对于解锁动作，v是被解锁的监视器。
     *          如果动作是一个(volatile或非volatile)读,v是被读的变量。
     *          如果动作是一个(volatile或非volatile)写，v是正在被写的变量。
     *      4.u - 一个任意的线程的唯一标识符。
     *
     *      一个外部动作的元组包含一个额外的组件，这个组件包含外部动作的结果。这可以是动作成功或失败的信息，
     *      和被这个动作读到的任何值。
     *
     *      外部动作的参数不是外部动作元组的一部分。这个参数被这个线程的其它动作设置，并且可以通过检查线程内的语义来确定
     *      他们在内存模型中没有明确的讨论。
     *
     *      在非终结执行中，不是所有外部操作可以被观察到。非终结操作和可观察动作在17.4.9中讨论。
     *
     *      17.4.3 程序和程序顺序。
     *
     *      在所有被线程t执行的inter-thread动作中，
     *
     *
     *
     *
     *
     *
     *
     */
}
