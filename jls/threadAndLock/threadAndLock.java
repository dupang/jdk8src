package jls.threadAndLock;

/**
 * Created by dupang on 2016/5/22.
 */
public class threadAndLock {
    /**
     * 当一个对象被创建，它的等待集合是空的。增加线程到和删除线程从等待集合中的基本的行为是自动的。
     * 等待集合被操控仅仅通过方法Object.wait,Object.notify,和Object.notifyAll.
     *
     * 等待集合的操控也可以受线程的中断状态的影响，和线程类的处理中断的方法。另外，Thread类的方法
     * sleeping和join()也来自等待和通过的操作。
     *
     * 等待行为发生在调用wait()方法的时候，或者定时的形式的wait(long millisecs)和wait(long millisecs,int nanosecs)
     *    调用wait(long millisecs)传入一个0的参数，或者调用wait(long millsecs,int nanosecs)传入两个0的参数，效果和
     *    调用wait()一样。
     *
     *    一个线程正常地返回从wait方法中，如果它没有抛出异常。
     *
     *    让线程t执行对象m的wait方法，并且n是线程t在对象m上锁操作的数量，并且还没有解锁的操作。
     *    下面的其中一件事发生：
     *    1.如果n是0，(也就是线程t还没有对m执行锁操作)，那么将抛出IllegalMonitorStateExceptio异常。
     *    2.如果这是一个定时的等待并且nanosecs参数范围不在0-999999，或者millisecs参数是负数，那么抛出
     *    IllegalArgumentException异常。
     *    3.如果 线程t被中断，那么抛出InterruptedException异常，并且t的中断状态被设置成false.
     *
     *
     *    否则，下面的顺序发生
     *
     *    1.线程t被加入到对象m的等待集合，并且执行n次解锁操作在m上。
     *    2.线程t不会执行任何更多的指令直到它被从m的等待队列上移除。线程可能从等待集合上移除由于下面的任何一个操作
     *      并且之后的某一时刻恢复。
     *      1》.在对象m上执行notify操作，并且t被选择从m的等待队列中移除。
     *      2》.在对象m上执行notifyAll操作，
     *      3》.在线程t上执行中断操作。
     *      4》.如果这是一个定时的wait,从m的等待中移除t至少经过millsecs毫秒加上nanosecs纳秒。
     *      5》.实现的内部操作，实现被允许，尽管不提倡，执行"虚假唤醒"，也就是说从等待集合中移除线程，并且使它恢复而
     *          没有明确的指令去执行这个。
     *
     *          注意这个规定需要Java编写wait只有在循环中，这个循环只在一些这个线程正在等待的条件满足的时候才终止。
     *
     *      每一个线程必须确定它被从等待集合移除的顺序，这个顺序不必和其它顺序一致，但是这个线程必须表现得像这个顺序
     *      一样。
     *
     *      例如，如果一个线程t正在m的等待集合上，然后线程t的中断和m的唤醒发生。在这些事件上必须有一个顺序。如果线程t
     *      的中断先发生，那么线程t从wait中返回，并抛出一个InterruptedException,并且其它线程在m的等待集合中必须接受到了
     *      唤醒通知。如果通知被认为先发生。那么t最终从wait方法中返回并且中断即将发生。
     *
     *      3.线程t执行n个锁操作在m对象上
     *      4.如果由于中断线程t从m的中断集合中移除。那么t的中断状态被设置成false,并且wait方法抛出InterruptedException.
     *
     *
     *      17.2.2 Notification
     *
     *      通知动作发生在notify和notifyAll方法的时候。
     *
     *      假如线程t是正在对象t上执行这些方法的的线程，并且n是t在m上的锁动作的数量并且没有还没有解锁。下面动作中的其中一个
     *      发生。
     *
     *      1. 如果n是0，那么抛出IllegalMonitorStateException异常。这就是t还没有持有对象m的锁的例子。
     *      2. 如果n是一个大于0的数，并且这是一个notify动作。那么如果m的当前等待集合不会空，线程u是m的等待集合中被选择的
     *         一员，并且从等待集合中移除。
     *
     *         没有保证那一个线程会从等待集合中被选择。从等待集合中移除使u从wait中恢复，然而请注意，在恢复时的u的锁动作不
     *         会成功直到t完全释放了m的监视器。
     *
     *      3. 如果n大于0并且这是一个notifyALl动作，然后所有线程被移除从m的等待集合中。
     *
     *          然而请注意一个时刻只有他们中的其中一个将锁住监视器在从wait中恢复的时候。
     *
     *     17.2.3  中断
     *
     *
     *     中断动作发生在在调用Thread.interrupt的时候，反过来方法被定义的类调用也可以，例如ThreadGroup.interrupt.
     *
     *     假如线程t正在调用u.interrupt,对于一些线程u,t和u可能是一样的。这个动作使u的中断判断被设置成true.
     *
     *     另外，如果存在对象m，它的等待集合中包含u，那么 u被移除从m的等待集合中。这使u从等待动作中恢复过来，
     *     这种情况这个等待将在重新锁m的监视器之后抛出interruption异常。
     *
     *     调用Thread.isInterrupted的方法可以确定一个线程的中断状态。静态方法Thread.interrupted可以被线程调用
     *     来查看它的中断状态并且清除它的中断状态。
     *
     *     17.2.4 等待，通知，和中断的相互影响
     *
     *     上面的规范允许我们确定等待，通知，中断的互相作用的一些属性。
     *
     *     如果一个线程在等待的时候被通知和中断，这可能:
     *     1 从wait中正常地返回，而随后会被中断(也就是说，调用Thread.interrupted将返回true)
     *     2 从wait中返回并抛出InterruptedException
     *
     *     线程可能不会重置它的中断状态并正常地从wati中返回。
     *
     *     相似地，因为中断通知不会错过。假如集合s是对象m的等待集合，并且其它线程执行了一个notify动作在m上。那么:
     *     1,至少一个在s中的线程必须正常地返回从wait中，或者
     *     2,所有s中的线程必须从wait中退出并抛出InterruptedException
     *
     *     注意如果一个线程被中断和通过notify唤醒，并且这个线程从wait中返回并抛出InterruptedException,那么一些其它线程
     *     在等待集合中必须被唤醒。
     *
     *     17.3 睡眠和让出
     *
     *     Thread.sleep 使当前执行线程休眠指定的时间，根据系统时钟和调度器的精度和精确度。这个线程不会丢失任何监视器的拥有权。
     *     并且恢复执行将根据调度和处理器的可用。
     *
     *     重要的是要注意Thread.sleep和Thread.yield没有任何同步语义。特别地，编译器不需要刷新缓存在寄存器里的写到共享内在中，在
     *     调用Thread.sleep和Thread.yield方法之前，编译器也不需要重新加载缓存在寄存里的值在调用Thread.sleep或Thread.yield.
     *
     *
     *          例如，在下面的代码片断，假如this.done是一个非volatile的布尔字段
     *
     *          while(!this.done)
     *             Thread.sleep(1000);
     *
     *
     *          编译器只读取this.done一次，并且使用缓存的值在每一次的循环执行中。也将意为着循环将永远不会终止，即使另一个线程改变了
     *          this.done的值。
     *
     *     17.4 内存模型
     *
     *     内在模型描述,给定一个程序和程序的执行轨迹,执行轨迹是否是合法的程序执行。Java语言的内存模型通过根据一些选定的规则判断每一个在一个执行轨迹中读
     *     并且检查被读看到的写是否正确来工作。
     *
     *     内在模型描述了一个程序的可能行为。实现可以自由地生成它喜欢的代码，只要所有的程序执行结果可以被内在模型预测。
     *
     *     这对实现者提供了很大地自由来实施各种各样的代码转换，包括执行动作重排序和移除不必要的同步。
     *
     *     例子 17.4.1 不成功的同步程序可能出现奇怪的行为。
     *
     *     Java的编程语言的语义允许编译器和微处理器实施优化可以和不正确的同步的代码产生貌似荒谬的行为。这里有一些例子，不正确的同步是怎么产生奇怪的
     *     行为的。
     *
     *     例如，考虑表格17.4.A中展示的例子程序轨迹，这个程序使用本地变量r1和r2和共享的变量A和B.开始A==B==0.
     *
     *
     *     表格 17.4.A 语句重排序导致的出人意料的结果--原始代码。
     *
     *     -------------------------------------------------------------------
     *     -   Thread 1                               Thread 2                                                              -
     *     -   1: r2=A                                 3:r1 = B                             -
     *     -   2: B=1;                                 4:A = 2                             -
     *     -                                                                 -
     *     -------------------------------------------------------------------
     *
     *     它可以出现不可能的结果 r2 == 2和r1 == 1.直观地，指行1或指行3应该首先执行。
     *     如果执行1先执行，它不能看到执令4的写。如果执令3先执行，它不可能看到执令2中的写。
     *
     *     如果一些执行展示了这个行为，那么我们应该知道执令4先于执令1,指令1先于执令2,执行2先于执令3,执令3先于执令4，。也就是说，这结果是
     *     荒谬的。
     *
     *     然而，编译器被允许在任一线程中重排序这些执令，在重排序不影响隔离的线程执行的时候。如果执令1和执行2被重排序了，就像表格17.4-B中展示的那样，
     *     那么很容易看到结果r2 == 2和r1 == 1 是怎么发生的。
     *
     *     Table 17.4-B
     *
     *     对于一些程序员，这个行为可能看起来像"损坏的"。然而，这应该记住这代码没有正确地同步。
     *        1. 一个线程有一个写。
     *        2. 一些变量被其它线程读。
     *        3. 并且读和写没有通过同步排序。
     *
     *     这种情况是一个数据竞争的例子。当代码包含数据竞争，违反直觉的结果经常是可能的。
     *
     *
     *     一些机制可以产生表格17.4-B中的重排序结果。一个Java虚拟机实现的Just-In-Time编译器可能重新编排代码，或者处理器。另外，运行Java虚拟机实现
     *     的架构的内存体系结构可能使它好像代码被重排序过一样。在这一章，我们将任何可以重排序的指的是编译器。
     *
     *     另一个奇怪的结果例子，可以在表格 17.4-C中看到。一开始，p == q并且p.x==0.p 这个程序也同步被不正确地同步了。它写一个共享内存而没有
     *     强调任何写之间的顺序。
     *
     *
     *     Table
     *
     *     一个普通的编译器优化包含使r2读到的值被r5重用：它们都是没有写干预的读。这个情况在Table17.4中展现。
     *
     *     现在考虑在线程2中发生的线程1中第一次r1.x和r3.x之间的r6.x的赋值操作的情况。如果编译器决定为r5重用r2的值，那么r2和r5都将会是0,并且
     *     r4将会是3.从程序员的角度看，存在这p.x中的值从0变成了3,并又变回来了。
     *
     *     内存模型决定在程序的每一点什么值可以被读到。每一个的独立的线程动作必须就像被这个线程的语义支配一样，除了被内存决定的每一个读线线程看到的值。
     *     当我们提到它的时候，我们说程序遵循内部线程语义。Intra-thread 语义是指的单线程程序的语义。而且允许基于线程内被读动作看到的值的完全预测的
     *     行为。为了确定线程t的行为是正确的，我们简单地计算线程t的实现，就像它可以在单线程的上下文中执行的一样。就像这个规范剩余部分定义的一样。
     *
     *
     *     每次线程t的赋值产生一个inter-thread动作，它必须符合按程序顺序接下来的inter-thread的线程t的a动作。如果a是一个读操作，那么使用这个a
     *     读到的值的来进行下次的t的计算。
     *
     *     这部分提供Java编程语言内存模型的规范，除了处理final字段的问题，这部分将在17.5描述。
     *
     *     这里指出的内存模型不是以Java编程语言的面向对象的特性为基础的。为了我们例子中的简洁和简单，
     *     我们经常展示没有类或方法的代码片断，或显式引用。大部分例子由两个或更多个线程组成 ，这些线程
     *     访问本地变量，共享全局变量，或者对象的实例字段。我们通常使用变量名字r1或r2表示方法或线程的
     *     本地变量。这些变量对其它线程不可访问。
     *
     *     17.4.1 共享变量
     *
     *     可以在线程之间共享的内存被称为共享内存或堆内存。
     *
     *     所有实例字段，static 字段，和数组元素被存储在堆内存。在这章，我们使用术语variable来表示字段和
     *     数组元素。
     *
     *     本地变量，正规的方法参数，和异常处理参数从来不在线程之间共享并且不受线程模型的影响。
     *
     *     相同的变量的两个访问(读或写)操作被认为是冲突的，如果至少其中的一个访问是写操作。
     *
     *     17.4.2 动作
     *
     *     一个inter-thread 动作是一个被一个线程执行的动作，可以被另一个线程检测到或直接影响。有一些
     *     程序可能执行的inter-thread 动作：
     *
     *     1. read(普通，或者not-volatile).读一个变量。
     *     2. write(普通，或者 non-volatile).写一个变量。
     *     3. 同步动作，这些是：
     *       -- Volatile read. 一个volatile变量的读。
     *       -- Volatile write 一个volatile变量的写。
     *       -- 锁 锁一个监视器
     *       -- 解锁 解锁一个监视器
     *       -- 线程的(合成的;  人造的;  摹拟的，虚构的;  [语]综合的)第一个和最后一个动作。
     *       -- 开始一个线程的动作或检测一个线程已经终结的动作。
     *
     *     4. 外部的动作。一个外部的动作是一个可能在一个执行操作外被查看的动作。并且具有一个基于执行
     *     的外部运行环境的结果。
     *
     *     5. Thread divergence actions。 线程分歧动作是只在一个无限循环被线程执行的动作，没有只在，同步，
     *     或者外部动作。如果线程执行一个线程分歧动作，它将被跟着大量的线程分歧动作。
     *
     *
     *     线程分歧动作被引入到模型，一个线程是怎么引起所有其它线程阻塞和失败进展的。
     *
     *     这个规范仅仅关注inter-thread动作。我们不需要关注intra-thread动作(比如，两个本地变量的
     *     相加并且存储结果到第三个本地变量中)。在前面提到的，所有线程需要遵循正确的Java程序intra-thread语义。
     *     我们将经常把inter-thread动作简称为actions.
     *
     *     一个动作a被描述为一个tuple<t,k,v,u>,相应地：
     *      1.t - 执行动作的线程。
     *      2.k - 动作的类型。
     *      3.v - 动作关联的变量或监视器。
     *          对于锁操作，v是被锁住的监视器，对于解锁动作，v是被解锁的监视器。
     *          如果动作是一个(volatile或非volatile)读,v是被读的变量。
     *          如果动作是一个(volatile或非volatile)写，v是正在被写的变量。
     *      4.u - 一个任意的线程的唯一标识符。
     *
     *      一个外部动作的元组包含一个额外的组件，这个组件包含外部动作的结果。这可以是动作成功或失败的信息，
     *      和被这个动作读到的任何值。
     *
     *      外部动作的参数不是外部动作元组的一部分。这个参数被这个线程的其它动作设置，并且可以通过检查线程内的语义来确定
     *      他们在内存模型中没有明确的讨论。
     *
     *      在非终结执行中，不是所有外部操作可以被观察到。非终结操作和可观察动作在17.4.9中讨论。
     *
     *      17.4.3 程序和程序顺序。
     *
     *      在所有被线程t执行的inter-thread动作中，t 的程序顺序是总的顺序，它返回了根据的t的intra-thread的语义
     *      这个动作应该被执行的顺序。
     *
     *      一组动作是顺序连贯的，如果所有的动作以和程序顺序一致的总顺序发生，并且每一个对变量v的读r.可以看到
     *      写w对v的写。例如：
     *
     *      1. 在执行顺序中w在r前面，并且
     *      2. 在执行顺序中，没有其它写操作w'，w在w'的前面并且w'在r的前面。
     *
     *      顺序的一致性是一个非常强的保证，在一个程序中关于可见性和顺序性。在一个顺序性一致的执行中，
     *      有一个和程序的顺序一致的总顺序在所有的单独动作上，并且每一个独立的动作是原子的并且对每一个
     *      线程来说立刻可见。
     *
     *      如果一个程序没有数据竞争，那么程序的所有执行将会是顺序一致。
     *
     *      顺序一致性和/或数据竞争的自由度仍然允许错误发生从一组需要和不需要感知原子性地操作中。
     *
     *      如果我们想使用顺序一致性作为我们的内存模型，
     *
     *
     *
     *
     *
     *
     *
     */
}
