package jls.threadAndLock;

/**
 * Created by dupang on 2016/5/22.
 */
public class threadAndLock {
    /**
     * 当一个对象被创建，它的等待集合是空的。增加线程到和删除线程从等待集合中的基本的行为是自动的。
     * 等待集合被操控仅仅通过方法Object.wait,Object.notify,和Object.notifyAll.
     *
     * 等待集合的操控也可以受线程的中断状态的影响，和线程类的处理中断的方法。另外，Thread类的方法
     * sleeping和join()也来自等待和通过的操作。
     *
     * 等待行为发生在调用wait()方法的时候，或者定时的形式的wait(long millisecs)和wait(long millisecs,int nanosecs)
     *    调用wait(long millisecs)传入一个0的参数，或者调用wait(long millsecs,int nanosecs)传入两个0的参数，效果和
     *    调用wait()一样。
     *
     *    一个线程正常地返回从wait方法中，如果它没有抛出异常。
     *
     *    让线程t执行对象m的wait方法，并且n是线程t在对象m上锁操作的数量，并且还没有解锁的操作。
     *    下面的其中一件事发生：
     *    1.如果n是0，(也就是线程t还没有对m执行锁操作)，那么将抛出IllegalMonitorStateExceptio异常。
     *    2.如果这是一个定时的等待并且nanosecs参数范围不在0-999999，或者millisecs参数是负数，那么抛出
     *    IllegalArgumentException异常。
     *    3.如果 线程t被中断，那么抛出InterruptedException异常，并且t的中断状态被设置成false.
     *
     *
     *    否则，下面的顺序发生
     *
     *    1.线程t被加入到对象m的等待集合，并且执行n次解锁操作在m上。
     *    2.线程t不会执行任何更多的指令直到它被从m的等待队列上移除。线程可能从等待集合上移除由于下面的任何一个操作
     *      并且之后的某一时刻恢复。
     *      1》.在对象m上执行notify操作，并且t被选择从m的等待队列中移除。
     *      2》.在对象m上执行notifyAll操作，
     *      3》.在线程t上执行中断操作。
     *      4》.如果这是一个定时的wait,从m的等待中移除t至少经过millsecs毫秒加上nanosecs纳秒。
     *      5》.实现的内部操作，实现被允许，尽管不提倡，执行"虚假唤醒"，也就是说从等待集合中移除线程，并且使它恢复而
     *          没有明确的指令去执行这个。
     *
     *          注意这个规定需要Java编写wait只有在循环中，这个循环只在一些这个线程正在等待的条件满足的时候才终止。
     *
     *      每一个线程必须确定它被从等待集合移除的顺序，这个顺序不必和其它顺序一致，但是这个线程必须表现得像这个顺序
     *      一样。
     *
     *      例如，如果一个线程t正在m的等待集合上，然后线程t的中断和m的唤醒发生。在这些事件上必须有一个顺序。如果线程t
     *      的中断先发生，那么线程t从wait中返回，并抛出一个InterruptedException,并且其它线程在m的等待集合中必须接受到了
     *      唤醒通知。如果通知被认为先发生。那么t最终从wait方法中返回并且中断即将发生。
     *
     *      3.线程t执行n个锁操作在m对象上
     *      4.如果由于中断线程t从m的中断集合中移除。那么t的中断状态被设置成false,并且wait方法抛出InterruptedException.
     *
     *
     *      17.2.2 Notification
     *
     *      通知动作发生在notify和notifyAll方法的时候。
     *
     *      假如线程t是正在对象t上执行这些方法的的线程，并且n是t在m上的锁动作的数量并且没有还没有解锁。下面动作中的其中一个
     *      发生。
     *
     *      1. 如果n是0，那么抛出IllegalMonitorStateException异常。这就是t还没有持有对象m的锁的例子。
     *      2. 如果n是一个大于0的数，并且这是一个notify动作。那么如果m的当前等待集合不会空，线程u是m的等待集合中被选择的
     *         一员，并且从等待集合中移除。
     *
     *         没有保证那一个线程会从等待集合中被选择。从等待集合中移除使u从wait中恢复，然而请注意，在恢复时的u的锁动作不
     *         会成功直到t完全释放了m的监视器。
     *
     *      3. 如果n大于0并且这是一个notifyALl动作，然后所有线程被移除从m的等待集合中。
     *
     *          然而请注意一个时刻只有他们中的其中一个将锁住监视器在从wait中恢复的时候。
     *
     *     17.2.3  中断
     *
     *
     *     中断动作发生在在调用Thread.interrupt的时候，反过来方法被定义的类调用也可以，例如ThreadGroup.interrupt.
     *
     *     假如线程t正在调用u.interrupt,对于一些线程u,t和u可能是一样的。这个动作使u的中断判断被设置成true.
     *
     *     另外，如果存在对象m，它的等待集合中包含u，那么 u被移除从m的等待集合中。这使u从等待动作中恢复过来，
     *     这种情况这个等待将在重新锁m的监视器之后抛出interruption异常。
     *
     *     调用Thread.isInterrupted的方法可以确定一个线程的中断状态。静态方法Thread.interrupted可以被线程调用
     *     来查看它的中断状态并且清除它的中断状态。
     *
     *     17.2.4 等待，通知，和中断的相互影响
     *
     *     上面的规范允许我们确定等待，通知，中断的互相作用的一些属性。
     *
     *     如果一个线程在等待的时候被通知和中断，这可能:
     *     1 从wait中正常地返回，而随后会被中断(也就是说，调用Thread.interrupted将返回true)
     *     2 从wait中返回并抛出InterruptedException
     *
     *     线程可能不会重置它的中断状态并正常地从wati中返回。
     *
     *     相似地，因为中断通知不会错过。假如集合s是对象m的等待集合，并且其它线程执行了一个notify动作在m上。那么:
     *     1,至少一个在s中的线程必须正常地返回从wait中，或者
     *     2,所有s中的线程必须从wait中退出并抛出InterruptedException
     *
     *     注意如果一个线程被中断和通过notify唤醒，并且这个线程从wait中返回并抛出InterruptedException,那么一些其它线程
     *     在等待集合中必须被唤醒。
     *
     *     17.3 睡眠和让出
     *
     *     Thread.sleep 使当前执行线程休眠指定的时间，根据系统时钟和调度器的精度和精确度。这个线程不会丢失任何监视器的拥有权。
     *     并且恢复执行将根据调度和处理器的可用。
     *
     *     重要的是要注意Thread.sleep和Thread.yield没有任何同步语义。特别地，编译器不需要刷新缓存在寄存器里的写到共享内在中，在
     *     调用Thread.sleep和Thread.yield方法之前，编译器也不需要重新加载缓存在寄存里的值在调用Thread.sleep或Thread.yield.
     *
     *
     *          例如，在下面的代码片断，假如this.done是一个非volatile的布尔字段
     *
     *          while(!this.done)
     *             Thread.sleep(1000);
     *
     *
     *          编译器只读取this.done一次，并且使用缓存的值在每一次的循环执行中。也将意为着循环将永远不会终止，即使另一个线程改变了
     *          this.done的值。
     *
     *     17.4 内存模型
     *
     *     内在模型描述,给定一个程序和程序的执行轨迹,执行轨迹是否是合法的程序执行。Java语言的内存模型通过根据一些选定的规则判断每一个在一个执行轨迹中读
     *     并且检查被读看到的写是否正确来工作。
     *
     *     内在模型描述了一个程序的可能行为。实现可以自由地生成它喜欢的代码，只要所有的程序执行结果可以被内在模型预测。
     *
     *     这对实现者提供了很大地自由来实施各种各样的代码转换，包括执行动作重排序和移除不必要的同步。
     *
     *     例子 17.4.1 不成功的同步程序可能出现奇怪的行为。
     *
     *     Java的编程语言的语义允许编译器和微处理器实施优化可以和不正确的同步的代码产生貌似荒谬的行为。这里有一些例子，不正确的同步是怎么产生奇怪的
     *     行为的。
     *
     *     例如，考虑表格17.4.A中展示的例子程序轨迹，这个程序使用本地变量r1和r2和共享的变量A和B.开始A==B==0.
     *
     *
     *     表格 17.4.A 语句重排序导致的出人意料的结果--原始代码。
     *
     *     -------------------------------------------------------------------
     *     -   Thread 1                               Thread 2                                                              -
     *     -   1: r2=A                                 3:r1 = B                             -
     *     -   2: B=1;                                 4:A = 2                             -
     *     -                                                                 -
     *     -------------------------------------------------------------------
     *
     *     它可以出现不可能的结果 r2 == 2和r1 == 1.直观地，指行1或指行3应该首先执行。
     *     如果执行1先执行，它不能看到执令4的写。如果执令3先执行，它不可能看到执令2中的写。
     *
     *     如果一些执行展示了这个行为，那么我们应该知道执令4先于执令1,指令1先于执令2,执行2先于执令3,执令3先于执令4，。也就是说，这结果是
     *     荒谬的。
     *
     *     然而，编译器被允许在任一线程中重排序这些执令，在重排序不影响隔离的线程执行的时候。如果执令1和执行2被重排序了，就像表格17.4-B中展示的那样，
     *     那么很容易看到结果r2 == 2和r1 == 1 是怎么发生的。
     *
     *     Table 17.4-B
     *
     *     对于一些程序员，这个行为可能看起来像"损坏的"。然而，这应该记住这代码没有正确地同步。
     *        1. 一个线程有一个写。
     *        2. 一些变量被其它线程读。
     *        3. 并且读和写没有通过同步排序。
     *
     *     这种情况是一个数据竞争的例子。当代码包含数据竞争，违反直觉的结果经常是可能的。
     *
     *
     *     一些机制可以产生表格17.4-B中的重排序结果。一个Java虚拟机实现的Just-In-Time编译器可能重新编排代码，或者处理器。另外，运行Java虚拟机实现
     *     的架构的内存体系结构可能使它好像代码被重排序过一样。在这一章，我们将任何可以重排序的指的是编译器。
     *
     *     另一个奇怪的结果例子，可以在表格 17.4-C中看到。一开始，p == q并且p.x==0.p 这个程序也同步被不正确地同步了。它写一个共享内存而没有
     *     强调任何写之间的顺序。
     *
     *
     *     Table
     *
     *     一个普通的编译器优化包含使r2读到的值被r5重用：它们都是没有写干预的读。这个情况在Table17.4中展现。
     *
     *     现在考虑在线程2中发生的线程1中第一次r1.x和r3.x之间的r6.x的赋值操作的情况。如果编译器决定为r5重用r2的值，那么r2和r5都将会是0,并且
     *     r4将会是3.从程序员的角度看，存在这p.x中的值从0变成了3,并又变回来了。
     *
     *     内存模型决定在程序的每一点什么值可以被读到。每一个的独立的线程动作必须就像被这个线程的语义支配一样，除了被内存决定的每一个读线线程看到的值。
     *     当我们提到它的时候，我们说程序遵循内部线程语义。Intra-thread 语义是指的单线程程序的语义。而且允许基于线程内被读动作看到的值的完全预测的
     *     行为。为了确定线程t的行为是正确的，我们简单地计算线程t的实现，就像它可以在单线程的上下文中执行的一样。就像这个规范剩余部分定义的一样。
     *
     *
     *     每次线程t的赋值产生一个inter-thread动作，它必须符合按程序顺序接下来的inter-thread的线程t的a动作。如果a是一个读操作，那么使用这个a
     *     读到的值的来进行下次的t的计算。
     *
     *
     *
     *
     */
}
