package jls.threadAndLock;

/**
 * Created by dupang on 2016/5/22.
 */
public class threadAndLock {
    /**
     * 当一个对象被创建，它的等待集合是空的。增加线程到和删除线程从等待集合中的基本的行为是自动的。
     * 等待集合被操控仅仅通过方法Object.wait,Object.notify,和Object.notifyAll.
     *
     * 等待集合的操控也可以受线程的中断状态的影响，和线程类的处理中断的方法。另外，Thread类的方法
     * sleeping和join()也来自等待和通过的操作。
     *
     * 等待行为发生在调用wait()方法的时候，或者定时的形式的wait(long millisecs)和wait(long millisecs,int nanosecs)
     *    调用wait(long millisecs)传入一个0的参数，或者调用wait(long millsecs,int nanosecs)传入两个0的参数，效果和
     *    调用wait()一样。
     *
     *    一个线程正常地返回从wait方法中，如果它没有抛出异常。
     *
     *    让线程t执行对象m的wait方法，并且n是线程t在对象m上锁操作的数量，并且还没有解锁的操作。
     *    下面的其中一件事发生：
     *    1.如果n是0，(也就是线程t还没有对m执行锁操作)，那么将抛出IllegalMonitorStateExceptio异常。
     *    2.如果这是一个定时的等待并且nanosecs参数范围不在0-999999，或者millisecs参数是负数，那么抛出
     *    IllegalArgumentException异常。
     *    3.如果 线程t被中断，那么抛出InterruptedException异常，并且t的中断状态被设置成false.
     *
     *
     *    否则，下面的顺序发生
     *
     *    1.线程t被加入到对象m的等待集合，并且执行n次解锁操作在m上。
     *    2.线程t不会执行任何更多的指令直到它被从m的等待队列上移除。线程可能从等待集合上移除由于下面的任何一个操作
     *      并且之后的某一时刻恢复。
     *      1》.在对象m上执行notify操作，并且t被选择从m的等待队列中移除。
     *      2》.在对象m上执行notifyAll操作，
     *      3》.在线程t上执行中断操作。
     *      4》.如果这是一个定时的wait,从m的等待中移除t至少经过millsecs毫秒加上nanosecs纳秒。
     *      5》.实现的内部操作，实现被允许，尽管不提倡，执行"虚假唤醒"，也就是说从等待集合中移除线程，并且使它恢复而
     *          没有明确的指令去执行这个。
     *
     *          注意这个规定需要Java编写wait只有在循环中，这个循环只在一些这个线程正在等待的条件满足的时候才终止。
     *
     *      每一个线程必须确定它被从等待集合移除的顺序，这个顺序不必和其它顺序一致，但是这个线程必须表现得像这个顺序
     *      一样。
     *
     *      例如，如果一个线程t正在m的等待集合上，然后线程t的中断和m的唤醒发生。在这些事件上必须有一个顺序。如果线程t
     *      的中断先发生，那么线程t从wait中返回，并抛出一个InterruptedException,并且其它线程在m的等待集合中必须接受到了
     *      唤醒通知。如果通知被认为先发生。那么t最终从wait方法中返回并且中断即将发生。
     *
     *      3.线程t执行n个锁操作在m对象上
     *      4.如果由于中断线程t从m的中断集合中移除。那么t的中断状态被设置成false,并且wait方法抛出InterruptedException.
     *
     *
     *      17.2.2 Notification
     *
     *      通知动作发生在notify和notifyAll方法的时候。
     *
     *      假如线程t是正在对象t上执行这些方法的的线程，并且n是t在m上的锁动作的数量并且没有还没有解锁。下面动作中的其中一个
     *      发生。
     *
     *      1. 如果n是0，那么抛出IllegalMonitorStateException异常。这就是t还没有持有对象m的锁的例子。
     *      2. 如果n是一个大于0的数，并且这是一个notify动作。那么如果m的当前等待集合不会空，线程u是m的等待集合中被选择的
     *         一员，并且从等待集合中移除。
     *
     *         没有保证那一个线程会从等待集合中被选择。从等待集合中移除使u从wait中恢复，然而请注意，在恢复时的u的锁动作不
     *         会成功直到t完全释放了m的监视器。
     *
     *      3. 如果n大于0并且这是一个notifyALl动作，然后所有线程被移除从m的等待集合中。
     *
     *          然而请注意一个时刻只有他们中的其中一个将锁住监视器在从wait中恢复的时候。
     *
     *     17.2.3  中断
     *
     *
     *     中断动作发生在在调用Thread.interrupt的时候，反过来方法被定义的类调用也可以，例如ThreadGroup.interrupt.
     *
     *     假如线程t正在调用u.interrupt,对于一些线程u,t和u可能是一样的。这个动作使u的中断判断被设置成true.
     *
     *     另外，如果存在对象m，它的等待集合中包含u，那么 u被移除从m的等待集合中。这使u从等待动作中恢复过来，
     *     这种情况这个等待将在重新锁m的监视器之后抛出interruption异常。
     *
     *     调用Thread.isInterrupted的方法可以确定一个线程的中断状态。静态方法Thread.interrupted可以被线程调用
     *     来查看它的中断状态并且清除它的中断状态。
     *
     *     17.2.4 等待，通知，和中断的相互影响
     *
     *     上面的规范允许我们确定等待，通知，中断的互相作用的一些属性。
     *
     *     如果一个线程在等待的时候被通知和中断，这可能:
     *     1 从wait中正常地返回，而随后会被中断(也就是说，调用Thread.interrupted将返回true)
     *     2 从wait中返回并抛出InterruptedException
     *
     *     线程可能不会重置它的中断状态并正常地从wati中返回。
     *
     *     相似地，因为中断通知不会错过。假如集合s是对象m的等待集合，并且其它线程执行了一个notify动作在m上。那么:
     *     1,至少一个在s中的线程必须正常地返回从wait中，或者
     *     2,所有s中的线程必须从wait中退出并抛出InterruptedException
     *
     *     注意如果一个线程被中断和通过notify唤醒，并且这个线程从wait中返回并抛出InterruptedException,那么一些其它线程
     *     在等待集合中必须被唤醒。
     *
     *     17.3 睡眠和让出
     *
     *     Thread.sleep 使当前执行线程休眠指定的时间，根据系统时钟和调度器的精度和精确度。这个线程不会丢失任何监视器的拥有权。
     *     并且恢复执行将根据调度和处理器的可用。
     *
     *     重要的是要注意Thread.sleep和Thread.yield没有任何同步语义。特别地，编译器不需要刷新缓存在寄存器里的写到共享内在中，在
     *     调用Thread.sleep和Thread.yield方法之前，编译器也不需要重新加载缓存在寄存里的值在调用Thread.sleep或Thread.yield.
     *
     *
     *          例如，在下面的代码片断，假如this.done是一个非volatile的布尔字段
     *
     *          while(!this.done)
     *             Thread.sleep(1000);
     *
     *
     *          编译器只读取this.done一次，并且使用缓存的值在每一次的循环执行中。也将意为着循环将永远不会终止，即使另一个线程改变了
     *          this.done的值。
     *
     *     17.4 内存模型
     *
     *     内在模型描述,给定一个程序和程序的执行轨迹,执行轨迹是否是合法的程序执行。Java语言的内存模型通过根据一些选定的规则判断每一个在一个执行轨迹中读
     *     并且检查被读看到的写是否正确来工作。
     *
     *     内在模型描述了一个程序的可能行为。实现可以自由地生成它喜欢的代码，只要所有的程序执行结果可以被内在模型预测。
     *
     *     这对实现者提供了很大地自由来实施各种各样的代码转换，包括执行动作重排序和移除不必要的同步。
     *
     *     例子 17.4.1 不成功的同步程序可能出现奇怪的行为。
     *
     *     Java的编程语言的语义允许编译器和微处理器实施优化可以和不正确的同步的代码产生貌似荒谬的行为。这里有一些例子，不正确的同步是怎么产生奇怪的
     *     行为的。
     *
     *     例如，考虑表格17.4.A中展示的例子程序轨迹，这个程序使用本地变量r1和r2和共享的变量A和B.开始A==B==0.
     *
     *
     *     表格 17.4.A 语句重排序导致的出人意料的结果--原始代码。
     *
     *     -------------------------------------------------------------------
     *     -   Thread 1                               Thread 2                                                              -
     *     -   1: r2=A                                 3:r1 = B                             -
     *     -   2: B=1;                                 4:A = 2                             -
     *     -                                                                 -
     *     -------------------------------------------------------------------
     *
     *     它可以出现不可能的结果 r2 == 2和r1 == 1.直观地，指行1或指行3应该首先执行。
     *     如果执行1先执行，它不能看到执令4的写。如果执令3先执行，它不可能看到执令2中的写。
     *
     *     如果一些执行展示了这个行为，那么我们应该知道执令4先于执令1,指令1先于执令2,执行2先于执令3,执令3先于执令4，。也就是说，这结果是
     *     荒谬的。
     *
     *     然而，编译器被允许在任一线程中重排序这些执令，在重排序不影响隔离的线程执行的时候。如果执令1和执行2被重排序了，就像表格17.4-B中展示的那样，
     *     那么很容易看到结果r2 == 2和r1 == 1 是怎么发生的。
     *
     *     Table 17.4-B
     *
     *     对于一些程序员，这个行为可能看起来像"损坏的"。然而，这应该记住这代码没有正确地同步。
     *        1. 一个线程有一个写。
     *        2. 一些变量被其它线程读。
     *        3. 并且读和写没有通过同步排序。
     *
     *     这种情况是一个数据竞争的例子。当代码包含数据竞争，违反直觉的结果经常是可能的。
     *
     *
     *     一些机制可以产生表格17.4-B中的重排序结果。一个Java虚拟机实现的Just-In-Time编译器可能重新编排代码，或者处理器。另外，运行Java虚拟机实现
     *     的架构的内存体系结构可能使它好像代码被重排序过一样。在这一章，我们将任何可以重排序的指的是编译器。
     *
     *     另一个奇怪的结果例子，可以在表格 17.4-C中看到。一开始，p == q并且p.x==0.p 这个程序也同步被不正确地同步了。它写一个共享内存而没有
     *     强调任何写之间的顺序。
     *
     *
     *     Table
     *
     *     一个普通的编译器优化包含使r2读到的值被r5重用：它们都是没有写干预的读。这个情况在Table17.4中展现。
     *
     *     现在考虑在线程2中发生的线程1中第一次r1.x和r3.x之间的r6.x的赋值操作的情况。如果编译器决定为r5重用r2的值，那么r2和r5都将会是0,并且
     *     r4将会是3.从程序员的角度看，存在这p.x中的值从0变成了3,并又变回来了。
     *
     *     内存模型决定在程序的每一点什么值可以被读到。每一个的独立的线程动作必须就像被这个线程的语义支配一样，除了被内存决定的每一个读线线程看到的值。
     *     当我们提到它的时候，我们说程序遵循内部线程语义。Intra-thread 语义是指的单线程程序的语义。而且允许基于线程内被读动作看到的值的完全预测的
     *     行为。为了确定线程t的行为是正确的，我们简单地计算线程t的实现，就像它可以在单线程的上下文中执行的一样。就像这个规范剩余部分定义的一样。
     *
     *
     *     每次线程t的赋值产生一个inter-thread动作，它必须符合按程序顺序接下来的inter-thread的线程t的a动作。如果a是一个读操作，那么使用这个a
     *     读到的值的来进行下次的t的计算。
     *
     *     这部分提供Java编程语言内存模型的规范，除了处理final字段的问题，这部分将在17.5描述。
     *
     *     这里指出的内存模型不是以Java编程语言的面向对象的特性为基础的。为了我们例子中的简洁和简单，
     *     我们经常展示没有类或方法的代码片断，或显式引用。大部分例子由两个或更多个线程组成 ，这些线程
     *     访问本地变量，共享全局变量，或者对象的实例字段。我们通常使用变量名字r1或r2表示方法或线程的
     *     本地变量。这些变量对其它线程不可访问。
     *
     *     17.4.1 共享变量
     *
     *     可以在线程之间共享的内存被称为共享内存或堆内存。
     *
     *     所有实例字段，static 字段，和数组元素被存储在堆内存。在这章，我们使用术语variable来表示字段和
     *     数组元素。
     *
     *     本地变量，正规的方法参数，和异常处理参数从来不在线程之间共享并且不受线程模型的影响。
     *
     *     相同的变量的两个访问(读或写)操作被认为是冲突的，如果至少其中的一个访问是写操作。
     *
     *     17.4.2 动作
     *
     *     一个inter-thread 动作是一个被一个线程执行的动作，可以被另一个线程检测到或直接影响。有一些
     *     程序可能执行的inter-thread 动作：
     *
     *     1. read(普通，或者not-volatile).读一个变量。
     *     2. write(普通，或者 non-volatile).写一个变量。
     *     3. 同步动作，这些是：
     *       -- Volatile read. 一个volatile变量的读。
     *       -- Volatile write 一个volatile变量的写。
     *       -- 锁 锁一个监视器
     *       -- 解锁 解锁一个监视器
     *       -- 线程的(合成的;  人造的;  摹拟的，虚构的;  [语]综合的)第一个和最后一个动作。
     *       -- 开始一个线程的动作或检测一个线程已经终结的动作。
     *
     *     4. 外部的动作。一个外部的动作是一个可能在一个执行操作外被查看的动作。并且具有一个基于执行
     *     的外部运行环境的结果。
     *
     *     5. Thread divergence actions。 线程分歧动作是只在一个无限循环被线程执行的动作，没有只在，同步，
     *     或者外部动作。如果线程执行一个线程分歧动作，它将被跟着大量的线程分歧动作。
     *
     *
     *     线程分歧动作被引入到模型，一个线程是怎么引起所有其它线程阻塞和失败进展的。
     *
     *     这个规范仅仅关注inter-thread动作。我们不需要关注intra-thread动作(比如，两个本地变量的
     *     相加并且存储结果到第三个本地变量中)。在前面提到的，所有线程需要遵循正确的Java程序intra-thread语义。
     *     我们将经常把inter-thread动作简称为actions.
     *
     *     一个动作a被描述为一个tuple<t,k,v,u>,相应地：
     *      1.t - 执行动作的线程。
     *      2.k - 动作的类型。
     *      3.v - 动作关联的变量或监视器。
     *          对于锁操作，v是被锁住的监视器，对于解锁动作，v是被解锁的监视器。
     *          如果动作是一个(volatile或非volatile)读,v是被读的变量。
     *          如果动作是一个(volatile或非volatile)写，v是正在被写的变量。
     *      4.u - 一个任意的线程的唯一标识符。
     *
     *      一个外部动作的元组包含一个额外的组件，这个组件包含外部动作的结果。这可以是动作成功或失败的信息，
     *      和被这个动作读到的任何值。
     *
     *      外部动作的参数不是外部动作元组的一部分。这个参数被这个线程的其它动作设置，并且可以通过检查线程内的语义来确定
     *      他们在内存模型中没有明确的讨论。
     *
     *      在非终结执行中，不是所有外部操作可以被观察到。非终结操作和可观察动作在17.4.9中讨论。
     *
     *      17.4.3 程序和程序顺序。
     *
     *      在所有被线程t执行的inter-thread动作中，t 的程序顺序是总的顺序，它返回了根据的t的intra-thread的语义
     *      这个动作应该被执行的顺序。
     *
     *      一组动作是顺序连贯的，如果所有的动作以和程序顺序一致的总顺序发生，并且每一个对变量v的读r.可以看到
     *      写w对v的写。例如：
     *
     *      1. 在执行顺序中w在r前面，并且
     *      2. 在执行顺序中，没有其它写操作w'，w在w'的前面并且w'在r的前面。
     *
     *      顺序的一致性是一个非常强的保证，在一个程序中关于可见性和顺序性。在一个顺序性一致的执行中，
     *      有一个和程序的顺序一致的总顺序在所有的单独动作上，并且每一个独立的动作是原子的并且对每一个
     *      线程来说立刻可见。
     *
     *      如果一个程序没有数据竞争，那么程序的所有执行将会是顺序一致。
     *
     *      顺序一致性和/或数据竞争的自由度仍然允许错误发生从一组需要和不需要感知原子性地操作中。
     *
     *      如果我们想使用顺序一致性作为我们的内存模型，很多我们讨论的编译器和处理的优化将是不合法的。例如，在表格17.4-C中的执行路径，
     *      只要3中的写p.x发生，随后的对这个地方的值的读将要求可以看到这个值。
     *
     *      17.4.4 同步顺序
     *
     *      每一个执行有一个同步顺序。同步顺序是一个在所有执行的同步动作上的总顺序。对于每一个线程t,同步动作的同步顺序和程序顺序是一致的。
     *
     *      同步动作诱导动作的同步化，定义如下:
     *      1.对监视器m的一个解锁操作和所有的随后(这里定义的"随后"根据同步顺序而定)锁动作都是同步的。
     *      2.对voriable变量v的写和所有随后的任意线程的v读是同步的。
     *      3.开始一个线程的动作和这个线程中的第一个动作是同步的。
     *      4.对每一个变量的默认值的写(0,false或者null)和每一个线程中的每一个动作是同步的。
     *            尽管在包含变量的对象被分配之前写一个变量的默认值它可能看起来很奇怪，从概念上来讲，在程序开始的时候对象被带着初始值创建。
     *
     *      5. 线程T1中的最后一个动作和另一个检测到T1已经终止的线程T2中的任何动作是同步的。
     *                  T2可以完成这个通过调用T1.isAlive()或T1.join().
     *
     *      6.如果线程T1中断了线程T2,T1的中断和任何其它线程检测到T2已经被中断的点是同步的(通过抛出一个InterruptedException和通过调用Thread.interrupted或者Thread.isInterrupted).
     *
     *      g 一个同步边缘的源被称为release,并且目的地被称为acquire.
     *
     *      17.4.5
     *
     *      两动作可以被排序通过一个happens-before的关系。如果一个动作happen-before另一个，那么第一个是可见的并且被排在第二个前面。
     *
     *      如果我们有两个动作x和主，我们用hb(x,y)来表示x happens-before y.
     *
     *         1.如果如果x和y是同一个线程的两个动作，并且以程序顺序来看x在y前面，那么hb(x,y).
     *         2.存在一个happens-before边缘，从对象的构建结束到这个对象的初始化。
     *         3.如果动作x和下面的动作y是同步的，那么hb(x,y).
     *         4.如果hb(x,y)并且hb(y,z),那么hb(x,z).
     *
     *      类Object的wait方法有lock和unlock动作和他们关联，它们的happen-before关系被这些关联关系确定。
     *
     *      应试记住两个动作的happens-before关系的存在，并不必然地意为他们在实现中执照这种顺序发生。如果重排序产生的结果和一个合理的执行一致，
     *      那么它不是合法的。
     *
     *         例如，被一个线程创建的一个对象的所有字段默认值的写不需要发生在线程的开始之前，只要没有读曾经觉察到这个事实。
     *
     *      更具体地说，如果两个动作具有happens-before关系，他们没必要在代码中以那种顺序出现。一个线程写一个数据和另一个线程的读竞争可能，例如，
     *      发生不正常对这些读来说。
     *
     *      happens-before 关系确定什么时候发生数据竞争。
     *
     *      一组同步边缘，S,是充足的，如果这是最小组这样程序顺序的S传递闭包确定所有的执行中happens-before边缘。
     *
     *      上的定义如下：
     *      1.一个监视器上的解锁操作happens-before每一个随后的这个监视器上的锁操作。
     *      2.对volatile字段的写hb每一个随后的这个字段的读。
     *      3.在一个线程上的start()方法调用，hb任何这个已经开始的线程的操作。
     *      4.一个线程的所有动作hb任何其它从这个线程join()方法正确返回的线程。
     *      5.任何对象 的默认初始化hb一个程序的任何(其它而不是默认-写)动作。
     *
     *
     *      当一个程序包含两个冲突的没有被hb关系排序好的访问，它被称为数据冲突。
     *
     *      操作的语义除了inter-thread 动作，例如数组长度的读取，转换检查的执行，和虚方法的调用，不被数据竞争直接影响。
     *
     *       因此，一个数据竞争不能引起不正确的行为，例如返回不正确的数组长度。
     *
     *      一个程序被正确地两步当且仅当所有的顺序地一致执行不受数据竞争影响。
     *
     *      如果一个程序被正确的同步，那么程序的所有的操作将会是顺序地一致。
     *
     *          这对程序员来说是极强的保证。程序员不需要考虑重排序来确定他们的代码包含数据竞争。因此他们不需要考虑重排序，当判定是否他们的代码被
     *          正确地同步。一旦确定了代码被正确地同步了，程序员不需要担心重排序将会影响他的代码。
     *
     *          一个程序必须正确地同步来避免在代码被重排序的时候出现的违反直觉的行为。正确同步的使用并不能保证程序的整个行为是正确的。使用它确定使
     *          程序员用一种简单的方式来考虑一个程序的可能行为；一个正确地同步的行为的程序很少地依赖可能的重排序。没有正确地同步，很奇怪，混乱，并且
     *          违反直觉行为是可能的。
     *
     *      我们说对变量v的读r，被允许看到w对v的写，如果以happens-before的执行顺序：
     *          1.r没有排在w前面（也就是说，不是hb(r,w)的情况），并且
     *          2.没有中间干预的w'对v的写（也就是说。没有对v的写操作w' hb(w,w')和hb(w',r)）.
     *       非正式地，一个读r被允许看到写w的结果，如果没有happens-before顺序阻止读。
     *
     *       一组动作Ahappens-before一致，如果对A中所有的读，W(r)是可以被r看到的读操作，如果不是hb(r,W(r)),或者那里存在一个写w在A中w.v=r.v
     *       并且hb(W(r),w)和hb(w,r).
     *
     *       在一组happens-before一致的操作中，每一个读可以看到一个读操作，它被允许通过happens-before顺序。
     *
     *
     *       17.4.6 执行
     *
     *
     *       17.5 final字段语义
     *
     *       被声明为final的字段初始化一次，但是在正常情况下永远不会被改变。final字段的详细语义从某种程度上说和普通的字段不同。特别地，编译器具有
     *       很大的自由度把final字段的读从同步屏障移动并且可以调用任意或未知的方法。相应地，编译器被允许保有final字段的缓存在一个寄存器并且不重新从主内在加载，
     *       而非final字段不得不重新从主内在加载。
     *
     *       final字段也允许程序员实现线程安全的不可变对象而不用同步。一个线程安全的不可变对象可以被所有线程看到，尽管一个数据单键经常在线程之间传递不可变对象的引用。
     *
     *       这可以提供安全保证以防被不正确或恶意的代码的不可变对象乱用。final字段必须被正确地使用来提供不可变的保证。
     *
     *       当一个对象的构造方法结束，它就被认为是完全地初始化了。一个线程只可以看到一个已经完全初始化好的对象引用，来保证看到这个对象的正确的final字段的值。
     *
     *       final字段的用例模型是一个简单的：在对象的构造方法中设置对象的final字段的值;并且在另一个线程中在构造方法结束之前不修改这个对象。
     *       如果按照这样的逻辑，那么当对象被另一个线程看到时，线程将总是看到对象的final字段的正确版本。它将会看到被final字段引用的任何对象的或数组的最少像final字段一样最新的版本。
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     */
}
